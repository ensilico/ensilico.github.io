<html>
    <head>
        <script src="ensilico.js"></script>
        <script>
            function Cast() {
                this.gravity = new Pair();
                this.gravity.load({
                    x: 0,
                    y: -9.81
                });

                var initialAngle = Scalar.toRadians(70);
                this.bot = new Bot({
                    position: {
                        x: 3,
                        y: -3
                    },
                    minAngle: initialAngle,
                    maxAngle: Scalar.toRadians(160),
                    period: 3,
                    dutyCycle: 0.5,
                    responsiveness: 5
                });

                // TODO: Introduce an align() method on Rod instead to be called post-construction
                var rodLength = 3;
                var pivotOffset = 0.2;
                var radius = rodLength - pivotOffset;
                this.rod = new Rod({
                    rodLength: rodLength,
                    pivotOffset: pivotOffset,
                    flexMass: 0.1,
                    flexSpring: 8.7,
                    flexDamping: 0.13,
                    flexDrag: 0.08,
                    tipPosition: {
                        x: radius * Math.cos(initialAngle),
                        y: radius * Math.sin(initialAngle)
                    }
                });
            }

            Cast.prototype.preferences = function() {
                return {
                    visualScale: 32,
                    stepsize: 0.001
                };
            }

            Cast.prototype.update = function(controls) {
                var stepsize = controls.stepsize;
                this.bot.update(stepsize, controls.holdSteady);

                // TODO: consider a loadPolar() method on Pair
                var targetPosition = new Pair();
                targetPosition.load({
                    x: this.rod.radius(),
                    y: 0
                });
                targetPosition.rotateBy(this.bot.angle);

                var targetVelocity = new Pair();
                targetVelocity.loadCrossProduct(this.bot.rate, targetPosition);

                this.rod.update(stepsize, this.gravity, new Pair(), targetPosition, targetVelocity);
            }

            Cast.prototype.visualize = function(context, elapsedTime) {
                context.save();
                context.translate(this.bot.position.x, this.bot.position.y);

                // TODO: loadPolar() as mentioned above
                var targetAxis = new Pair();
                targetAxis.load({
                    x: 1,
                    y: 0
                });
                targetAxis.rotateBy(this.bot.angle);

                // TODO: eliminate redundancy as mentioned above
                var rodAxis = new Pair();
                this.rod.storeTipPosition(rodAxis);
                rodAxis.divideBy(rodAxis.norm() + Scalar.tiny());

                // Piecewise linear approximation of rod flex curve
                var p = new Pair();
                var NUM_SEGMENTS = 20;
                for (var i = 0; i <= NUM_SEGMENTS; i++) {
                    var t = i / NUM_SEGMENTS;
                    var r = t * this.rod.getRodLength() - this.rod.getPivotOffset();
                    p.loadLerp(targetAxis, rodAxis, t).multiplyBy(r);
                    if (i == 0) {
                        context.moveTo(p.x, p.y);
                    } else {
                        context.lineTo(p.x, p.y);
                    }
                }

                context.restore();
            }

            function Bot(properties) {
                // Default values
                this.position = {
                    x: 0,
                    y: 0
                };
                this.minAngle = 0;
                this.maxAngle = Scalar.toRadians(90);
                this.period = 1;
                this.dutyCycle = 0.5;
                this.responsiveness = 1;

                // Allow caller to override
                Platform.softCopy(this, properties);

                this.angle = this.minAngle;
                this.rate = 0;
                this.time = 0;
            }

            Bot.prototype.update = function(stepsize, holdSteady) {
                var target = (this.time < this.dutyCycle * this.period) ? this.minAngle : this.maxAngle;
                this.rate = Scalar.lagRate(this.angle, target, this.responsiveness, stepsize);
                this.angle += stepsize * this.rate;
                if (!holdSteady) {
                    this.time = (this.time + stepsize) % this.period;
                }
            }
       </script>
    </head>
    <body onload="Executive.start(new Cast(), 'visual')">
        <canvas id="visual" width="800" height="600">
            Opps.
        </canvas>
    </body>
</html>
